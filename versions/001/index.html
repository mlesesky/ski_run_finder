<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Ski Run Flyover POC</title>
    <link href="https://unpkg.com/cesium@1.115.0/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
      html,body,#cesiumContainer{height:100%;width:100%;margin:0;padding:0;overflow:hidden}
      #ui{position:absolute;left:8px;top:8px;z-index:2;background:rgba(255,255,255,0.9);padding:10px;border-radius:6px;font:13px/1.2 "Segoe UI",Tahoma,sans-serif}
      #ui .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-top:6px}
      #ui label{font-weight:600}
      #ui input[type=range]{width:160px}
      #meta{margin-top:6px;font-size:12px}
      #meta .metaLabel{font-weight:600}
      #status{margin-top:6px;font-style:italic}
      #panelHeader{margin-top:0}
      #ui.collapsed .row:not(#panelHeader), #ui.collapsed #meta, #ui.collapsed #status{display:none}
      #hud{position:absolute;right:10px;bottom:10px;background:rgba(0,0,0,0.55);color:#fff;padding:6px 8px;border-radius:6px;font:11px/1.3 "Segoe UI",Tahoma,sans-serif;z-index:2}
    </style>
  </head>
  <body>
    <div id="cesiumContainer"></div>
    <div id="ui">
      <div class="row" id="panelHeader">
        <strong>Controls</strong>
        <button id="togglePanel">Minimize</button>
      </div>
      <div class="row">
        <label for="resortSelect">Resort</label>
        <select id="resortSelect"></select>
      </div>
      <div class="row">
        <label for="runSelect">Run</label>
        <select id="runSelect"></select>
        <label for="difficultyFilter">Difficulty</label>
        <select id="difficultyFilter">
          <option value="all">All</option>
          <option value="green">Green</option>
          <option value="blue">Blue</option>
          <option value="black">Black</option>
          <option value="double_black">Double black</option>
          <option value="unknown">Unknown</option>
        </select>
        <button id="start">Start Flyover</button>
        <button id="pause" disabled>Pause</button>
      </div>
      <div class="row">
        <label for="speed">Speed</label>
        <input id="speed" type="range" min="20" max="200" step="1" value="100">
        <span id="speedValue">100</span> m/s
      </div>
      <div class="row">
        <label for="range">Range</label>
        <input id="range" type="range" min="50" max="800" step="25" value="100">
        <span id="rangeValue">100</span> m
      </div>
      <div class="row">
        <label><input id="toggleRuns" type="checkbox" checked> All runs</label>
        <label><input id="toggleRunLabels" type="checkbox"> Run labels</label>
        <label><input id="toggleLifts" type="checkbox" checked> Lifts</label>
        <label><input id="toggleLiftLabels" type="checkbox"> Lift labels</label>
        <label><input id="toggleBuildings" type="checkbox"> Buildings</label>
      </div>
      <div id="meta">
        <div><span class="metaLabel">Name:</span> <span id="metaName">-</span></div>
        <div><span class="metaLabel">Difficulty:</span> <span id="metaDifficulty">-</span></div>
        <div><span class="metaLabel">Length:</span> <span id="metaLength">-</span></div>
        <div><span class="metaLabel">Vertical drop:</span> <span id="metaDrop">-</span></div>
        <div><span class="metaLabel">Avg slope:</span> <span id="metaSlope">-</span></div>
      </div>
      <div id="status"></div>
    </div>
    <div id="hud"></div>

    <script src="https://unpkg.com/cesium@1.115.0/Build/Cesium/Cesium.js"></script>
    <script>
      Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmZjhkZDA3OS1iOTI0LTQzMjMtOTA1ZS1mMjRlODQ3MjMzY2MiLCJpZCI6MzgwMjMxLCJpYXQiOjE3Njg2OTkyMTF9.3SYENMo5wG8dipBrHLDUPgtV9t-mb6Ns2H4D55IQg8I';

      let viewer;
      let resorts = [];
      let currentResort = null;
      let runCoords = [];
      let runsByName = new Map();
      let currentRunName = '';
      let currentRunEntity = null;
      let allRunsDataSource = null;
      let liftsDataSource = null;
      let buildingsTileset = null;
      let flyoverTick = null;
      let isPaused = false;
      let flightBaseSpeed = 40;
      let resortSelect;
      let runSelect;
      let difficultyFilter;
      let runLabelsToggle;
      let liftLabelsToggle;
      let pauseButton;
      let panelToggleButton;
      let panelEl;
      let speedInput;
      let rangeInput;
      let speedValue;
      let rangeValue;
      let metaName;
      let metaDifficulty;
      let metaLength;
      let metaDrop;
      let metaSlope;
      let hudEl;
      let currentRunsFeatures = [];
      let terrainReadyPromise = Promise.resolve(false);
      const STORAGE_RESORT_KEY = 'skiRunFinder.resort';
      const STORAGE_RUN_KEY_PREFIX = 'skiRunFinder.run.';
      const STORAGE_PANEL_KEY = 'skiRunFinder.panelCollapsed';
      const RESORT_VIEWS = {
        whistler_blackcomb: {
          lon: -123.13,
          lat: 50.25,
          height: 14000,
          heading: 145,
          pitch: -22
        }
      };

      async function fetchGeojson(url) {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Failed to load ${url}`);
        return res.json();
      }

      function normalizeDifficulty(props) {
        const raw = (props && (props.difficulty || props['piste:difficulty'] || props.difficulty_raw)) || '';
        const val = String(raw).trim().toLowerCase();
        if (val === 'green') return 'green';
        if (val === 'blue') return 'blue';
        if (val === 'black') return 'black';
        if (val === 'double_black') return 'double_black';
        if (val === 'easy' || val === 'novice' || val === 'beginner') return 'green';
        if (val === 'intermediate' || val === 'medium') return 'blue';
        if (val === 'advanced' || val === 'hard' || val === 'difficult') return 'black';
        if (val === 'expert' || val === 'extreme') return 'double_black';
        return 'unknown';
      }

      function difficultyLabel(difficulty) {
        if (difficulty === 'green') return 'Green';
        if (difficulty === 'blue') return 'Blue';
        if (difficulty === 'black') return 'Black';
        if (difficulty === 'double_black') return 'Double black';
        return 'Unknown';
      }

      function difficultyColor(difficulty) {
        if (difficulty === 'green') return Cesium.Color.fromCssColorString('#2ecc71');
        if (difficulty === 'blue') return Cesium.Color.fromCssColorString('#3498db');
        if (difficulty === 'black') return Cesium.Color.fromCssColorString('#2d3436');
        if (difficulty === 'double_black') return Cesium.Color.fromCssColorString('#000000');
        return Cesium.Color.fromCssColorString('#f39c12');
      }

      function labelStyle(text, maxDistance) {
        return {
          text,
          font: '12px "Segoe UI", Tahoma, sans-serif',
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 2,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -8),
          distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0.0, maxDistance || 1200),
          scaleByDistance: new Cesium.NearFarScalar(300, 1.0, (maxDistance || 1200), 0.0)
        };
      }

      function labelPosition(coords, heightOffset) {
        if (!coords || coords.length === 0) return Cesium.Cartesian3.ZERO;
        const mid = coords[Math.floor(coords.length / 2)];
        const ground = heightForCoord(mid[0], mid[1], 0);
        return Cesium.Cartesian3.fromDegrees(mid[0], mid[1], ground + (heightOffset || 25));
      }

      function formatMeters(value) {
        if (value === null || value === undefined || Number.isNaN(value)) return '-';
        return `${Math.round(value)} m`;
      }

      function formatSlope(verticalDrop, runLength) {
        if (!verticalDrop || !runLength) return '-';
        const ratio = verticalDrop / runLength;
        const percent = ratio * 100;
        const degrees = Math.atan(ratio) * (180 / Math.PI);
        return `${percent.toFixed(1)}% (${degrees.toFixed(1)}째)`;
      }

      function getRunNameFromEntity(entity) {
        if (!entity || !entity.properties) return null;
        const props = entity.properties.getValue
          ? entity.properties.getValue(viewer.clock.currentTime)
          : entity.properties;
        if (!props || props.type !== 'run') return null;
        return props.runName || null;
      }

      function lineLengthMeters(coords) {
        let total = 0;
        for (let i = 1; i < coords.length; i++) {
          const a = Cesium.Cartesian3.fromDegrees(coords[i - 1][0], coords[i - 1][1], 0);
          const b = Cesium.Cartesian3.fromDegrees(coords[i][0], coords[i][1], 0);
          total += Cesium.Cartesian3.distance(a, b);
        }
        return total;
      }

      function decimateCoords(coords, maxPoints) {
        if (coords.length <= maxPoints) return coords;
        const step = Math.ceil(coords.length / maxPoints);
        const reduced = [];
        for (let i = 0; i < coords.length; i += step) {
          reduced.push(coords[i]);
        }
        if (reduced[reduced.length - 1] !== coords[coords.length - 1]) {
          reduced.push(coords[coords.length - 1]);
        }
        return reduced;
      }

      async function sampleRunHeights(coords) {
        const sample = decimateCoords(coords, 200);
        const cartos = sample.map(c => Cesium.Cartographic.fromDegrees(c[0], c[1]));
        const terrainReady = await terrainReadyPromise;
        if (terrainReady) {
          try {
            await Cesium.sampleTerrainMostDetailed(viewer.terrainProvider, cartos);
          } catch (e) {
            console.warn('Terrain sampling failed, falling back to globe heights.', e);
          }
        }
        for (const carto of cartos) {
          if (!carto.height || carto.height === 0) {
            const h = viewer.scene.globe.getHeight(carto);
            carto.height = (h === undefined || h === null) ? 0 : h;
          }
        }
        return cartos.map(c => c.height || 0);
      }

      async function updateRunMeta(feat) {
        if (!feat || !feat.properties || !feat.geometry) return;
        const props = feat.properties;
        const name = props.name || 'Run';
        const difficulty = difficultyLabel(normalizeDifficulty(props));
        const length = props.length_m || lineLengthMeters(feat.geometry.coordinates);
        metaName.textContent = name;
        metaDifficulty.textContent = difficulty;
        metaLength.textContent = formatMeters(length);
        metaDrop.textContent = 'Calculating...';
        metaSlope.textContent = 'Calculating...';

        try {
          const heights = await sampleRunHeights(feat.geometry.coordinates);
          const maxH = Math.max(...heights);
          const minH = Math.min(...heights);
          const drop = maxH - minH;
          metaDrop.textContent = formatMeters(drop);
          metaSlope.textContent = formatSlope(drop, length);
        } catch (e) {
          console.warn('Failed to compute run stats.', e);
          metaDrop.textContent = '-';
          metaSlope.textContent = '-';
        }
      }

      function buildAllRunsLayer(features) {
        if (!allRunsDataSource) {
          allRunsDataSource = new Cesium.CustomDataSource('allRuns');
          viewer.dataSources.add(allRunsDataSource);
        }
        allRunsDataSource.entities.removeAll();
        const showLabels = runLabelsToggle ? runLabelsToggle.checked : false;
        const filter = difficultyFilter ? difficultyFilter.value : 'all';
        for (const feat of features) {
          const coords = feat.geometry.coordinates;
          const flat = [].concat(...coords.map(c => [c[0], c[1]]));
          const difficulty = normalizeDifficulty(feat.properties || {});
          if (filter !== 'all' && difficulty !== filter) continue;
          const color = difficultyColor(difficulty);
          const entity = allRunsDataSource.entities.add({
            name: feat.properties.name,
            polyline: {
              positions: Cesium.Cartesian3.fromDegreesArray(flat),
              width: 3,
              material: color,
              clampToGround: true
            },
            position: labelPosition(coords, 25),
            label: Object.assign(labelStyle(feat.properties.name, 1200), { show: showLabels }),
            properties: new Cesium.PropertyBag({
              type: 'run',
              runName: feat.properties.name
            })
          });
        }
        const showAll = document.getElementById('toggleRuns').checked;
        allRunsDataSource.show = showAll;
      }

      function refreshRunOverlay() {
        if (!currentRunsFeatures || currentRunsFeatures.length === 0) return;
        buildAllRunsLayer(currentRunsFeatures);
      }

      async function setRun(name, options = {}) {
        const feat = runsByName.get(name);
        if (!feat || feat.geometry.type !== 'LineString') return;
        stopFlyover();
        currentRunName = name;
        if (runSelect && runSelect.value !== name) runSelect.value = name;
        if (currentResort) {
          localStorage.setItem(`${STORAGE_RUN_KEY_PREFIX}${currentResort.id}`, name);
        }
        runCoords = feat.geometry.coordinates;
        const flat = [].concat(...runCoords.map(c => [c[0], c[1]]));
        if (currentRunEntity) viewer.entities.remove(currentRunEntity);
        const difficulty = normalizeDifficulty(feat.properties || {});
        const activeColor = difficulty === 'unknown' ? Cesium.Color.ORANGE : difficultyColor(difficulty);
        const showLabel = runLabelsToggle ? runLabelsToggle.checked : false;
        currentRunEntity = viewer.entities.add({
          polyline: {
            positions: Cesium.Cartesian3.fromDegreesArray(flat),
            width: 6,
            material: activeColor,
            clampToGround: true
          },
          position: labelPosition(runCoords, 35),
          label: Object.assign(labelStyle(feat.properties.name, 1200), { show: showLabel }),
          properties: new Cesium.PropertyBag({
            type: 'run',
            runName: feat.properties.name
          })
        });
        if (options.zoomToRun !== false) {
          await viewer.zoomTo(currentRunEntity);
        }
        const length = feat.properties && feat.properties.length_m;
        const suffix = length ? ` (${length} m)` : '';
        const diffLabel = difficultyLabel(difficulty);
        document.getElementById('status').textContent = `Run loaded: ${feat.properties.name}${suffix} - ${diffLabel}`;
        await updateRunMeta(feat);
      }

      function populateRunSelect(preferredName) {
        const filter = difficultyFilter.value;
        const entries = [];
        for (const [name, feat] of runsByName.entries()) {
          const difficulty = normalizeDifficulty(feat.properties || {});
          if (filter !== 'all' && difficulty !== filter) continue;
          entries.push({ name, difficulty });
        }

        runSelect.innerHTML = '';
        if (entries.length === 0) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'No runs';
          runSelect.appendChild(opt);
          runSelect.disabled = true;
          return null;
        }
        runSelect.disabled = false;

        for (const entry of entries) {
          const opt = document.createElement('option');
          opt.value = entry.name;
          const diffLabel = difficultyLabel(entry.difficulty);
          opt.textContent = `${entry.name} (${diffLabel})`;
          runSelect.appendChild(opt);
        }

        const names = entries.map(e => e.name);
        const selected = names.includes(preferredName) ? preferredName : names[0];
        runSelect.value = selected;
        return selected;
      }

      async function applyRunFilter() {
        const selected = populateRunSelect(currentRunName);
        refreshRunOverlay();
        if (selected && selected !== currentRunName) {
          await setRun(selected, { zoomToRun: false });
        }
      }

      async function loadRunsForResort(resort) {
        if (!resort || !resort.runs) throw new Error('Resort runs not configured.');
        const geo = await fetchGeojson(resort.runs);
        const features = (geo.features || []).filter(f => f.geometry && f.geometry.type === 'LineString');
        if (features.length === 0) throw new Error('No LineString runs found.');

        runsByName = new Map();
        currentRunsFeatures = features;
        let idx = 1;
        for (const feat of features) {
          const name = (feat.properties && feat.properties.name) ? feat.properties.name : `Run ${idx++}`;
          const difficulty = normalizeDifficulty(feat.properties || {});
          feat.properties = Object.assign({}, feat.properties, { name, difficulty });
          runsByName.set(name, feat);
        }

        refreshRunOverlay();

        const storedRun = currentResort ? localStorage.getItem(`${STORAGE_RUN_KEY_PREFIX}${currentResort.id}`) : null;
        const preferred = runsByName.has(storedRun) ? storedRun : (runsByName.has('Harmony Ridge') ? 'Harmony Ridge' : null);
        const selected = populateRunSelect(preferred);
        if (selected) {
          await setRun(selected, { zoomToRun: false });
        }
      }

      function applyResortView(resort) {
        const view = resort && RESORT_VIEWS[resort.id];
        if (!view) return;
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(view.lon, view.lat, view.height),
          orientation: {
            heading: Cesium.Math.toRadians(view.heading),
            pitch: Cesium.Math.toRadians(view.pitch),
            roll: 0.0
          },
          duration: 1.6
        });
      }

      async function setResort(resortId) {
        const resort = resorts.find(r => r.id === resortId) || resorts[0];
        if (!resort) return;
        stopFlyover();
        currentResort = resort;
        localStorage.setItem(STORAGE_RESORT_KEY, resort.id);

        if (liftsDataSource) {
          viewer.dataSources.remove(liftsDataSource);
          liftsDataSource = null;
        }
        if (allRunsDataSource) {
          allRunsDataSource.entities.removeAll();
        }

        await loadRunsForResort(resort);
        applyResortView(resort);

        if (document.getElementById('toggleLifts').checked) {
          await toggleLifts(true);
        }
      }

      async function loadResorts() {
        let data;
        try {
          data = await fetchGeojson('resorts.json');
        } catch (e) {
          console.warn('resorts.json not found, using default resort.', e);
          data = {
            resorts: [
              {
                id: 'default',
                name: 'Default',
                runs: 'run.geojson'
              }
            ]
          };
        }

        resorts = Array.isArray(data.resorts) ? data.resorts : [];
        if (resorts.length === 0) throw new Error('No resorts configured.');

        resortSelect.innerHTML = '';
        for (const resort of resorts) {
          const opt = document.createElement('option');
          opt.value = resort.id;
          opt.textContent = resort.name;
          resortSelect.appendChild(opt);
        }

        const storedResort = localStorage.getItem(STORAGE_RESORT_KEY);
        const initial = resorts.find(r => r.id === storedResort) || resorts[0];
        resortSelect.value = initial.id;
        await setResort(initial.id);
      }

      function bearingDegrees(a, b) {
        const [lon1, lat1] = a.map(Cesium.Math.toRadians);
        const [lon2, lat2] = b.map(Cesium.Math.toRadians);
        const dLon = lon2 - lon1;
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        const brng = Math.atan2(y, x);
        return (Cesium.Math.toDegrees(brng) + 360) % 360;
      }

      function unwrapHeading(prevRad, nextRad) {
        let delta = nextRad - prevRad;
        if (delta > Math.PI) nextRad -= Math.PI * 2;
        if (delta < -Math.PI) nextRad += Math.PI * 2;
        return nextRad;
      }

      function heightForCoord(lon, lat, fallback) {
        const carto = Cesium.Cartographic.fromDegrees(lon, lat);
        const h = viewer.scene.globe.getHeight(carto);
        return (h === undefined || h === null) ? fallback : h;
      }

      function buildFlightSamples(coords, metersPerSecond) {
        const positions = new Cesium.SampledPositionProperty();
        const headings = new Cesium.SampledProperty(Number);
        const start = Cesium.JulianDate.now();
        let lastHeading = null;

        let t = 0;
        for (let i = 0; i < coords.length; i++) {
          const prev = coords[i - 1] || coords[i];
          const cur = coords[i];
          const next = coords[i + 1] || coords[i];
          let headingRad = Cesium.Math.toRadians(bearingDegrees(prev, next));
          if (lastHeading !== null) headingRad = unwrapHeading(lastHeading, headingRad);

          if (i > 0) {
            const dist = Cesium.Cartesian3.distance(
              Cesium.Cartesian3.fromDegrees(prev[0], prev[1], 0),
              Cesium.Cartesian3.fromDegrees(cur[0], cur[1], 0)
            );
            t += dist / metersPerSecond;
          }

          const time = Cesium.JulianDate.addSeconds(start, t, new Cesium.JulianDate());
          const ground = heightForCoord(cur[0], cur[1], 0);
          const position = Cesium.Cartesian3.fromDegrees(cur[0], cur[1], ground + 5);
          positions.addSample(time, position);
          headings.addSample(time, headingRad);
          lastHeading = headingRad;
        }

        return { start, end: Cesium.JulianDate.addSeconds(start, t, new Cesium.JulianDate()), positions, headings };
      }

      function stopFlyover() {
        if (!flyoverTick) return;
        viewer.clock.onTick.removeEventListener(flyoverTick);
        viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
        flyoverTick = null;
        isPaused = false;
        viewer.clock.shouldAnimate = true;
        if (pauseButton) {
          pauseButton.textContent = 'Pause';
          pauseButton.disabled = true;
        }
      }

      function setPauseState(paused) {
        if (!flyoverTick) return;
        isPaused = paused;
        viewer.clock.shouldAnimate = !paused;
        pauseButton.textContent = paused ? 'Resume' : 'Pause';
        document.getElementById('status').textContent = paused ? 'Paused' : 'Flying...';
      }

      function setRunLabelVisibility(show) {
        if (allRunsDataSource) {
          for (const entity of allRunsDataSource.entities.values) {
            if (entity.label) entity.label.show = show;
          }
        }
        if (currentRunEntity && currentRunEntity.label) {
          currentRunEntity.label.show = show;
        }
      }

      function setLiftLabelVisibility(show) {
        if (!liftsDataSource) return;
        for (const entity of liftsDataSource.entities.values) {
          if (entity.label) entity.label.show = show;
        }
      }

      async function flyover(coords) {
        if (!coords || coords.length < 2) return;
        stopFlyover();
        document.getElementById('status').textContent = 'Flying...';
        if (pauseButton) {
          pauseButton.disabled = false;
          pauseButton.textContent = 'Pause';
        }
        isPaused = false;

        const top = coords[0];
        const topNext = coords[1] || coords[0];
        const topHeading = bearingDegrees(top, topNext);
        const topHeight = heightForCoord(top[0], top[1], 0);
        await viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(top[0], top[1], topHeight + 1200),
          orientation: {
            heading: Cesium.Math.toRadians(topHeading),
            pitch: Cesium.Math.toRadians(-35),
            roll: 0.0
          },
          duration: 2.0
        });

        const speed = Number(speedInput.value || 100);
        const samples = buildFlightSamples(coords, speed);
        flightBaseSpeed = speed;
        viewer.clock.startTime = samples.start.clone();
        viewer.clock.stopTime = samples.end.clone();
        viewer.clock.currentTime = samples.start.clone();
        viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
        viewer.clock.multiplier = 1;

        const camera = viewer.camera;
        const scratch = new Cesium.Cartesian3();

        const pitch = Cesium.Math.toRadians(-25);
        flyoverTick = (clock) => {
          const time = clock.currentTime;
          const pos = samples.positions.getValue(time, scratch);
          if (!pos) return;
          const heading = samples.headings.getValue(time);
          const rangeMeters = Number(rangeInput.value || 300);
          camera.lookAt(pos, new Cesium.HeadingPitchRange(heading, pitch, rangeMeters));

          if (Cesium.JulianDate.greaterThanOrEquals(time, samples.end)) {
            viewer.clock.onTick.removeEventListener(flyoverTick);
            viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
            flyoverTick = null;
            isPaused = false;
            if (pauseButton) {
              pauseButton.textContent = 'Pause';
              pauseButton.disabled = true;
            }
            document.getElementById('status').textContent = 'Flyover complete';
            applyResortView(currentResort);
          }
        };

        viewer.clock.onTick.addEventListener(flyoverTick);
      }

      async function toggleBuildings(show) {
        if (!show) {
          if (buildingsTileset) buildingsTileset.show = false;
          return;
        }
        if (!buildingsTileset) {
          document.getElementById('status').textContent = 'Loading buildings...';
          buildingsTileset = await Cesium.createOsmBuildingsAsync();
          viewer.scene.primitives.add(buildingsTileset);
        }
        buildingsTileset.show = true;
      }

      async function toggleLifts(show) {
        if (!show) {
          if (liftsDataSource) liftsDataSource.show = false;
          return;
        }
        if (!liftsDataSource) {
          document.getElementById('status').textContent = 'Loading lifts...';
          if (!currentResort || !currentResort.lifts) {
            document.getElementById('status').textContent = 'No lifts data for resort';
            return;
          }
          const geo = await fetchGeojson(currentResort.lifts);
          liftsDataSource = new Cesium.CustomDataSource('lifts');
          const showLabels = liftLabelsToggle ? liftLabelsToggle.checked : false;
          for (const feat of geo.features || []) {
            if (!feat.geometry || feat.geometry.type !== 'LineString') continue;
            const coords = feat.geometry.coordinates;
            const flat = [].concat(...coords.map(c => [c[0], c[1]]));
            const name = (feat.properties && feat.properties.name) ? feat.properties.name : 'Lift';
            liftsDataSource.entities.add({
              name,
              polyline: {
                positions: Cesium.Cartesian3.fromDegreesArray(flat),
                width: 2,
                material: new Cesium.PolylineDashMaterialProperty({
                  color: Cesium.Color.RED,
                  dashLength: 16
                }),
                clampToGround: true
              },
              position: labelPosition(coords, 35),
              label: Object.assign(labelStyle(name, 1200), { show: showLabels })
            });

            const start = coords[0];
            const end = coords[coords.length - 1];
            liftsDataSource.entities.add({
              name: `${name} Station`,
              position: Cesium.Cartesian3.fromDegrees(start[0], start[1], heightForCoord(start[0], start[1], 0) + 10),
              point: {
                pixelSize: 6,
                color: Cesium.Color.RED,
                outlineColor: Cesium.Color.WHITE,
                outlineWidth: 1
              },
              label: Object.assign(labelStyle(name, 1000), { show: showLabels })
            });
            if (end && (end[0] !== start[0] || end[1] !== start[1])) {
              liftsDataSource.entities.add({
                name: `${name} Station`,
                position: Cesium.Cartesian3.fromDegrees(end[0], end[1], heightForCoord(end[0], end[1], 0) + 10),
                point: {
                  pixelSize: 6,
                  color: Cesium.Color.RED,
                  outlineColor: Cesium.Color.WHITE,
                  outlineWidth: 1
                },
                label: Object.assign(labelStyle(name, 1000), { show: showLabels })
              });
            }
          }
          viewer.dataSources.add(liftsDataSource);
        }
        liftsDataSource.show = true;
      }

      async function init() {
        viewer = new Cesium.Viewer('cesiumContainer', {
          timeline: false,
          animation: false,
          baseLayerPicker: false,
          terrainProvider: new Cesium.EllipsoidTerrainProvider()
        });
        viewer.scene.globe.depthTestAgainstTerrain = true;
        viewer.scene.globe.maximumScreenSpaceError = 2;
        viewer.scene.globe.tileCacheSize = 1000;
        viewer.scene.fog.enabled = false;
        viewer.scene.postProcessStages.fxaa.enabled = true;
        viewer.resolutionScale = Math.min(window.devicePixelRatio, 2);
        viewer.clock.shouldAnimate = true;
        viewer.scene.postRender.addEventListener(() => {
          if (!hudEl) return;
          const cam = viewer.camera;
          const carto = Cesium.Cartographic.fromCartesian(cam.position);
          const lat = Cesium.Math.toDegrees(carto.latitude);
          const lon = Cesium.Math.toDegrees(carto.longitude);
          const height = carto.height;
          const heading = Cesium.Math.toDegrees(cam.heading);
          const pitch = Cesium.Math.toDegrees(cam.pitch);
          const roll = Cesium.Math.toDegrees(cam.roll);
          const fmt = (v, n) => (Number.isFinite(v) ? v.toFixed(n) : '-');
          hudEl.innerHTML = `Lat ${fmt(lat, 5)}<br>Lon ${fmt(lon, 5)}<br>Alt ${fmt(height, 0)} m<br>Head ${fmt(heading, 1)}째<br>Pitch ${fmt(pitch, 1)}째<br>Roll ${fmt(roll, 1)}째`;
        });

        viewer.imageryLayers.removeAll();
        document.getElementById('status').textContent = 'Loading imagery...';
        let imageryLoaded = false;
        try {
          const ionImagery = await Cesium.IonImageryProvider.fromAssetId(2);
          viewer.imageryLayers.addImageryProvider(ionImagery);
          imageryLoaded = true;
          document.getElementById('status').textContent = 'Imagery loaded (Ion)';
        } catch (e) {
          console.warn('Ion imagery failed, falling back to OSM.', e);
        }

        if (!imageryLoaded) {
          try {
            const osm = new Cesium.OpenStreetMapImageryProvider({
              url: 'https://a.tile.openstreetmap.org/'
            });
            viewer.imageryLayers.addImageryProvider(osm);
            imageryLoaded = true;
            document.getElementById('status').textContent = 'Imagery loaded (OSM)';
          } catch (e) {
            console.warn('OSM imagery failed.', e);
            document.getElementById('status').textContent = 'Imagery unavailable';
          }
        }

        document.getElementById('status').textContent = 'Loading terrain...';
        terrainReadyPromise = (async () => {
          try {
            const terrain = await Cesium.createWorldTerrainAsync();
            viewer.terrainProvider = terrain;
            document.getElementById('status').textContent = 'Terrain loaded';
            return true;
          } catch (e) {
            console.warn('Terrain failed to load, using ellipsoid.', e);
            document.getElementById('status').textContent = 'Terrain unavailable, using ellipsoid';
            return false;
          }
        })();
        await terrainReadyPromise;

        document.getElementById('start').addEventListener('click', () => flyover(runCoords));

        panelEl = document.getElementById('ui');
        panelToggleButton = document.getElementById('togglePanel');
        hudEl = document.getElementById('hud');
        resortSelect = document.getElementById('resortSelect');
        runSelect = document.getElementById('runSelect');
        difficultyFilter = document.getElementById('difficultyFilter');
        runLabelsToggle = document.getElementById('toggleRunLabels');
        liftLabelsToggle = document.getElementById('toggleLiftLabels');
        pauseButton = document.getElementById('pause');
        speedInput = document.getElementById('speed');
        rangeInput = document.getElementById('range');
        speedValue = document.getElementById('speedValue');
        rangeValue = document.getElementById('rangeValue');
        metaName = document.getElementById('metaName');
        metaDifficulty = document.getElementById('metaDifficulty');
        metaLength = document.getElementById('metaLength');
        metaDrop = document.getElementById('metaDrop');
        metaSlope = document.getElementById('metaSlope');
        const syncValues = () => {
          speedValue.textContent = speedInput.value;
          rangeValue.textContent = rangeInput.value;
          if (flyoverTick) {
            viewer.clock.multiplier = Number(speedInput.value || 100) / flightBaseSpeed;
          }
        };
        speedInput.addEventListener('input', syncValues);
        rangeInput.addEventListener('input', syncValues);
        syncValues();

        resortSelect.addEventListener('change', (e) => setResort(e.target.value));
        runSelect.addEventListener('change', (e) => setRun(e.target.value));
        difficultyFilter.addEventListener('change', () => applyRunFilter());
        document.getElementById('toggleRuns').addEventListener('change', (e) => {
          if (allRunsDataSource) allRunsDataSource.show = e.target.checked;
          refreshRunOverlay();
        });
        document.getElementById('toggleLifts').addEventListener('change', (e) => toggleLifts(e.target.checked));
        runLabelsToggle.addEventListener('change', (e) => setRunLabelVisibility(e.target.checked));
        liftLabelsToggle.addEventListener('change', (e) => setLiftLabelVisibility(e.target.checked));
        document.getElementById('toggleBuildings').addEventListener('change', (e) => toggleBuildings(e.target.checked));
        pauseButton.addEventListener('click', () => setPauseState(!isPaused));

        const applyPanelState = (collapsed) => {
          panelEl.classList.toggle('collapsed', collapsed);
          panelToggleButton.textContent = collapsed ? 'Expand' : 'Minimize';
          localStorage.setItem(STORAGE_PANEL_KEY, collapsed ? '1' : '0');
        };
        panelToggleButton.addEventListener('click', () => {
          const collapsed = panelEl.classList.contains('collapsed');
          applyPanelState(!collapsed);
        });
        const storedPanel = localStorage.getItem(STORAGE_PANEL_KEY);
        applyPanelState(storedPanel === '1');

        viewer.selectedEntityChanged.addEventListener((entity) => {
          const runName = getRunNameFromEntity(entity);
          if (runName && runName !== currentRunName) {
            setRun(runName, { zoomToRun: false });
          }
        });

        viewer.trackedEntityChanged.addEventListener((entity) => {
          const runName = getRunNameFromEntity(entity);
          if (!runName) return;
          if (runName !== currentRunName) {
            setRun(runName, { zoomToRun: false }).then(() => flyover(runCoords));
          } else {
            flyover(runCoords);
          }
        });

        await loadResorts();
        if (document.getElementById('toggleLifts').checked) {
          await toggleLifts(true);
        }
        if (document.getElementById('toggleRuns').checked) {
          refreshRunOverlay();
        }
      }

      init();
    </script>
  </body>
</html>
